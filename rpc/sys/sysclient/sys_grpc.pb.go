// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.4
// source: rpc/sys/sys.proto

package sysclient

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AuthService_Register_FullMethodName     = "/sysclient.AuthService/Register"
	AuthService_Login_FullMethodName        = "/sysclient.AuthService/Login"
	AuthService_RefreshToken_FullMethodName = "/sysclient.AuthService/RefreshToken"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 认证服务
type AuthServiceClient interface {
	// 注册
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	// 用户登录
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	// 刷新令牌
	RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, AuthService_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AuthService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshTokenResponse)
	err := c.cc.Invoke(ctx, AuthService_RefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
//
// 认证服务
type AuthServiceServer interface {
	// 注册
	Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
	// 用户登录
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	// 刷新令牌
	RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedAuthServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAuthServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	// If the following call pancis, it indicates UnimplementedAuthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sysclient.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _AuthService_Register_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _AuthService_Login_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _AuthService_RefreshToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/sys/sys.proto",
}

const (
	OperateLogService_AddOperateLog_FullMethodName         = "/sysclient.OperateLogService/AddOperateLog"
	OperateLogService_DeleteOperateLog_FullMethodName      = "/sysclient.OperateLogService/DeleteOperateLog"
	OperateLogService_QueryOperateLogDetail_FullMethodName = "/sysclient.OperateLogService/QueryOperateLogDetail"
	OperateLogService_QueryOperateLogList_FullMethodName   = "/sysclient.OperateLogService/QueryOperateLogList"
)

// OperateLogServiceClient is the client API for OperateLogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 系统操作日志表
type OperateLogServiceClient interface {
	// 添加系统操作日志表
	AddOperateLog(ctx context.Context, in *AddOperateLogReq, opts ...grpc.CallOption) (*AddOperateLogResp, error)
	// 删除系统操作日志表
	DeleteOperateLog(ctx context.Context, in *DeleteOperateLogReq, opts ...grpc.CallOption) (*DeleteOperateLogResp, error)
	// 查询系统操作日志表详情
	QueryOperateLogDetail(ctx context.Context, in *QueryOperateLogDetailReq, opts ...grpc.CallOption) (*OperateLog, error)
	// 查询系统操作日志表列表
	QueryOperateLogList(ctx context.Context, in *QueryOperateLogListReq, opts ...grpc.CallOption) (*OperateLogListData, error)
}

type operateLogServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOperateLogServiceClient(cc grpc.ClientConnInterface) OperateLogServiceClient {
	return &operateLogServiceClient{cc}
}

func (c *operateLogServiceClient) AddOperateLog(ctx context.Context, in *AddOperateLogReq, opts ...grpc.CallOption) (*AddOperateLogResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddOperateLogResp)
	err := c.cc.Invoke(ctx, OperateLogService_AddOperateLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operateLogServiceClient) DeleteOperateLog(ctx context.Context, in *DeleteOperateLogReq, opts ...grpc.CallOption) (*DeleteOperateLogResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteOperateLogResp)
	err := c.cc.Invoke(ctx, OperateLogService_DeleteOperateLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operateLogServiceClient) QueryOperateLogDetail(ctx context.Context, in *QueryOperateLogDetailReq, opts ...grpc.CallOption) (*OperateLog, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperateLog)
	err := c.cc.Invoke(ctx, OperateLogService_QueryOperateLogDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operateLogServiceClient) QueryOperateLogList(ctx context.Context, in *QueryOperateLogListReq, opts ...grpc.CallOption) (*OperateLogListData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperateLogListData)
	err := c.cc.Invoke(ctx, OperateLogService_QueryOperateLogList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OperateLogServiceServer is the server API for OperateLogService service.
// All implementations must embed UnimplementedOperateLogServiceServer
// for forward compatibility.
//
// 系统操作日志表
type OperateLogServiceServer interface {
	// 添加系统操作日志表
	AddOperateLog(context.Context, *AddOperateLogReq) (*AddOperateLogResp, error)
	// 删除系统操作日志表
	DeleteOperateLog(context.Context, *DeleteOperateLogReq) (*DeleteOperateLogResp, error)
	// 查询系统操作日志表详情
	QueryOperateLogDetail(context.Context, *QueryOperateLogDetailReq) (*OperateLog, error)
	// 查询系统操作日志表列表
	QueryOperateLogList(context.Context, *QueryOperateLogListReq) (*OperateLogListData, error)
	mustEmbedUnimplementedOperateLogServiceServer()
}

// UnimplementedOperateLogServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOperateLogServiceServer struct{}

func (UnimplementedOperateLogServiceServer) AddOperateLog(context.Context, *AddOperateLogReq) (*AddOperateLogResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddOperateLog not implemented")
}
func (UnimplementedOperateLogServiceServer) DeleteOperateLog(context.Context, *DeleteOperateLogReq) (*DeleteOperateLogResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOperateLog not implemented")
}
func (UnimplementedOperateLogServiceServer) QueryOperateLogDetail(context.Context, *QueryOperateLogDetailReq) (*OperateLog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryOperateLogDetail not implemented")
}
func (UnimplementedOperateLogServiceServer) QueryOperateLogList(context.Context, *QueryOperateLogListReq) (*OperateLogListData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryOperateLogList not implemented")
}
func (UnimplementedOperateLogServiceServer) mustEmbedUnimplementedOperateLogServiceServer() {}
func (UnimplementedOperateLogServiceServer) testEmbeddedByValue()                           {}

// UnsafeOperateLogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OperateLogServiceServer will
// result in compilation errors.
type UnsafeOperateLogServiceServer interface {
	mustEmbedUnimplementedOperateLogServiceServer()
}

func RegisterOperateLogServiceServer(s grpc.ServiceRegistrar, srv OperateLogServiceServer) {
	// If the following call pancis, it indicates UnimplementedOperateLogServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OperateLogService_ServiceDesc, srv)
}

func _OperateLogService_AddOperateLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddOperateLogReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperateLogServiceServer).AddOperateLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperateLogService_AddOperateLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperateLogServiceServer).AddOperateLog(ctx, req.(*AddOperateLogReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperateLogService_DeleteOperateLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteOperateLogReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperateLogServiceServer).DeleteOperateLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperateLogService_DeleteOperateLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperateLogServiceServer).DeleteOperateLog(ctx, req.(*DeleteOperateLogReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperateLogService_QueryOperateLogDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryOperateLogDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperateLogServiceServer).QueryOperateLogDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperateLogService_QueryOperateLogDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperateLogServiceServer).QueryOperateLogDetail(ctx, req.(*QueryOperateLogDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperateLogService_QueryOperateLogList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryOperateLogListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperateLogServiceServer).QueryOperateLogList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OperateLogService_QueryOperateLogList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperateLogServiceServer).QueryOperateLogList(ctx, req.(*QueryOperateLogListReq))
	}
	return interceptor(ctx, in, info, handler)
}

// OperateLogService_ServiceDesc is the grpc.ServiceDesc for OperateLogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OperateLogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sysclient.OperateLogService",
	HandlerType: (*OperateLogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddOperateLog",
			Handler:    _OperateLogService_AddOperateLog_Handler,
		},
		{
			MethodName: "DeleteOperateLog",
			Handler:    _OperateLogService_DeleteOperateLog_Handler,
		},
		{
			MethodName: "QueryOperateLogDetail",
			Handler:    _OperateLogService_QueryOperateLogDetail_Handler,
		},
		{
			MethodName: "QueryOperateLogList",
			Handler:    _OperateLogService_QueryOperateLogList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/sys/sys.proto",
}

const (
	RoleService_GetRoleList_FullMethodName          = "/sysclient.RoleService/GetRoleList"
	RoleService_CreateRole_FullMethodName           = "/sysclient.RoleService/CreateRole"
	RoleService_UpdateRole_FullMethodName           = "/sysclient.RoleService/UpdateRole"
	RoleService_ToggleRoleStatus_FullMethodName     = "/sysclient.RoleService/ToggleRoleStatus"
	RoleService_DeleteRole_FullMethodName           = "/sysclient.RoleService/DeleteRole"
	RoleService_BatchDeleteRoles_FullMethodName     = "/sysclient.RoleService/BatchDeleteRoles"
	RoleService_AddRolePerms_FullMethodName         = "/sysclient.RoleService/AddRolePerms"
	RoleService_UpdateRolePerms_FullMethodName      = "/sysclient.RoleService/UpdateRolePerms"
	RoleService_DeleteRolePerms_FullMethodName      = "/sysclient.RoleService/DeleteRolePerms"
	RoleService_GetRolePerms_FullMethodName         = "/sysclient.RoleService/GetRolePerms"
	RoleService_GetRoleListByRoleIDs_FullMethodName = "/sysclient.RoleService/GetRoleListByRoleIDs"
)

// RoleServiceClient is the client API for RoleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleServiceClient interface {
	// 角色列表
	GetRoleList(ctx context.Context, in *RoleListRequest, opts ...grpc.CallOption) (*RoleListResponse, error)
	// 创建角色
	CreateRole(ctx context.Context, in *CreateRoleRequest, opts ...grpc.CallOption) (*Role, error)
	// 更新角色
	UpdateRole(ctx context.Context, in *UpdateRoleRequest, opts ...grpc.CallOption) (*Role, error)
	// 禁用角色
	ToggleRoleStatus(ctx context.Context, in *ToggleRoleStatusRequest, opts ...grpc.CallOption) (*Role, error)
	// 删除角色
	DeleteRole(ctx context.Context, in *DeleteRoleRequest, opts ...grpc.CallOption) (*Empty, error)
	BatchDeleteRoles(ctx context.Context, in *BatchDeleteRolesRequest, opts ...grpc.CallOption) (*Empty, error)
	// 添加角色权限
	AddRolePerms(ctx context.Context, in *AddRolePermsRequest, opts ...grpc.CallOption) (*RoleInfo, error)
	// 更新角色权限
	UpdateRolePerms(ctx context.Context, in *UpdateRolePermsRequest, opts ...grpc.CallOption) (*RoleInfo, error)
	// 删除角色权限
	DeleteRolePerms(ctx context.Context, in *DeleteRolePermsRequest, opts ...grpc.CallOption) (*RoleInfo, error)
	// 获取角色权限
	GetRolePerms(ctx context.Context, in *GetRolePermsRequest, opts ...grpc.CallOption) (*RoleInfo, error)
	// 获取角色列表
	GetRoleListByRoleIDs(ctx context.Context, in *GetRoleByRoleCodesRequest, opts ...grpc.CallOption) (*GetRoleByRoleCodesResponse, error)
}

type roleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleServiceClient(cc grpc.ClientConnInterface) RoleServiceClient {
	return &roleServiceClient{cc}
}

func (c *roleServiceClient) GetRoleList(ctx context.Context, in *RoleListRequest, opts ...grpc.CallOption) (*RoleListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleListResponse)
	err := c.cc.Invoke(ctx, RoleService_GetRoleList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) CreateRole(ctx context.Context, in *CreateRoleRequest, opts ...grpc.CallOption) (*Role, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Role)
	err := c.cc.Invoke(ctx, RoleService_CreateRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) UpdateRole(ctx context.Context, in *UpdateRoleRequest, opts ...grpc.CallOption) (*Role, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Role)
	err := c.cc.Invoke(ctx, RoleService_UpdateRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) ToggleRoleStatus(ctx context.Context, in *ToggleRoleStatusRequest, opts ...grpc.CallOption) (*Role, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Role)
	err := c.cc.Invoke(ctx, RoleService_ToggleRoleStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) DeleteRole(ctx context.Context, in *DeleteRoleRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, RoleService_DeleteRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) BatchDeleteRoles(ctx context.Context, in *BatchDeleteRolesRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, RoleService_BatchDeleteRoles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) AddRolePerms(ctx context.Context, in *AddRolePermsRequest, opts ...grpc.CallOption) (*RoleInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleInfo)
	err := c.cc.Invoke(ctx, RoleService_AddRolePerms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) UpdateRolePerms(ctx context.Context, in *UpdateRolePermsRequest, opts ...grpc.CallOption) (*RoleInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleInfo)
	err := c.cc.Invoke(ctx, RoleService_UpdateRolePerms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) DeleteRolePerms(ctx context.Context, in *DeleteRolePermsRequest, opts ...grpc.CallOption) (*RoleInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleInfo)
	err := c.cc.Invoke(ctx, RoleService_DeleteRolePerms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) GetRolePerms(ctx context.Context, in *GetRolePermsRequest, opts ...grpc.CallOption) (*RoleInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleInfo)
	err := c.cc.Invoke(ctx, RoleService_GetRolePerms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) GetRoleListByRoleIDs(ctx context.Context, in *GetRoleByRoleCodesRequest, opts ...grpc.CallOption) (*GetRoleByRoleCodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRoleByRoleCodesResponse)
	err := c.cc.Invoke(ctx, RoleService_GetRoleListByRoleIDs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleServiceServer is the server API for RoleService service.
// All implementations must embed UnimplementedRoleServiceServer
// for forward compatibility.
type RoleServiceServer interface {
	// 角色列表
	GetRoleList(context.Context, *RoleListRequest) (*RoleListResponse, error)
	// 创建角色
	CreateRole(context.Context, *CreateRoleRequest) (*Role, error)
	// 更新角色
	UpdateRole(context.Context, *UpdateRoleRequest) (*Role, error)
	// 禁用角色
	ToggleRoleStatus(context.Context, *ToggleRoleStatusRequest) (*Role, error)
	// 删除角色
	DeleteRole(context.Context, *DeleteRoleRequest) (*Empty, error)
	BatchDeleteRoles(context.Context, *BatchDeleteRolesRequest) (*Empty, error)
	// 添加角色权限
	AddRolePerms(context.Context, *AddRolePermsRequest) (*RoleInfo, error)
	// 更新角色权限
	UpdateRolePerms(context.Context, *UpdateRolePermsRequest) (*RoleInfo, error)
	// 删除角色权限
	DeleteRolePerms(context.Context, *DeleteRolePermsRequest) (*RoleInfo, error)
	// 获取角色权限
	GetRolePerms(context.Context, *GetRolePermsRequest) (*RoleInfo, error)
	// 获取角色列表
	GetRoleListByRoleIDs(context.Context, *GetRoleByRoleCodesRequest) (*GetRoleByRoleCodesResponse, error)
	mustEmbedUnimplementedRoleServiceServer()
}

// UnimplementedRoleServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRoleServiceServer struct{}

func (UnimplementedRoleServiceServer) GetRoleList(context.Context, *RoleListRequest) (*RoleListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoleList not implemented")
}
func (UnimplementedRoleServiceServer) CreateRole(context.Context, *CreateRoleRequest) (*Role, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRole not implemented")
}
func (UnimplementedRoleServiceServer) UpdateRole(context.Context, *UpdateRoleRequest) (*Role, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRole not implemented")
}
func (UnimplementedRoleServiceServer) ToggleRoleStatus(context.Context, *ToggleRoleStatusRequest) (*Role, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToggleRoleStatus not implemented")
}
func (UnimplementedRoleServiceServer) DeleteRole(context.Context, *DeleteRoleRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}
func (UnimplementedRoleServiceServer) BatchDeleteRoles(context.Context, *BatchDeleteRolesRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchDeleteRoles not implemented")
}
func (UnimplementedRoleServiceServer) AddRolePerms(context.Context, *AddRolePermsRequest) (*RoleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRolePerms not implemented")
}
func (UnimplementedRoleServiceServer) UpdateRolePerms(context.Context, *UpdateRolePermsRequest) (*RoleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRolePerms not implemented")
}
func (UnimplementedRoleServiceServer) DeleteRolePerms(context.Context, *DeleteRolePermsRequest) (*RoleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRolePerms not implemented")
}
func (UnimplementedRoleServiceServer) GetRolePerms(context.Context, *GetRolePermsRequest) (*RoleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRolePerms not implemented")
}
func (UnimplementedRoleServiceServer) GetRoleListByRoleIDs(context.Context, *GetRoleByRoleCodesRequest) (*GetRoleByRoleCodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoleListByRoleIDs not implemented")
}
func (UnimplementedRoleServiceServer) mustEmbedUnimplementedRoleServiceServer() {}
func (UnimplementedRoleServiceServer) testEmbeddedByValue()                     {}

// UnsafeRoleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleServiceServer will
// result in compilation errors.
type UnsafeRoleServiceServer interface {
	mustEmbedUnimplementedRoleServiceServer()
}

func RegisterRoleServiceServer(s grpc.ServiceRegistrar, srv RoleServiceServer) {
	// If the following call pancis, it indicates UnimplementedRoleServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RoleService_ServiceDesc, srv)
}

func _RoleService_GetRoleList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).GetRoleList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_GetRoleList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).GetRoleList(ctx, req.(*RoleListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_CreateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).CreateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_CreateRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).CreateRole(ctx, req.(*CreateRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_UpdateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).UpdateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_UpdateRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).UpdateRole(ctx, req.(*UpdateRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_ToggleRoleStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleRoleStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).ToggleRoleStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_ToggleRoleStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).ToggleRoleStatus(ctx, req.(*ToggleRoleStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_DeleteRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).DeleteRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_DeleteRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).DeleteRole(ctx, req.(*DeleteRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_BatchDeleteRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchDeleteRolesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).BatchDeleteRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_BatchDeleteRoles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).BatchDeleteRoles(ctx, req.(*BatchDeleteRolesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_AddRolePerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRolePermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).AddRolePerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_AddRolePerms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).AddRolePerms(ctx, req.(*AddRolePermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_UpdateRolePerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRolePermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).UpdateRolePerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_UpdateRolePerms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).UpdateRolePerms(ctx, req.(*UpdateRolePermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_DeleteRolePerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRolePermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).DeleteRolePerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_DeleteRolePerms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).DeleteRolePerms(ctx, req.(*DeleteRolePermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_GetRolePerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRolePermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).GetRolePerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_GetRolePerms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).GetRolePerms(ctx, req.(*GetRolePermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_GetRoleListByRoleIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoleByRoleCodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).GetRoleListByRoleIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_GetRoleListByRoleIDs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).GetRoleListByRoleIDs(ctx, req.(*GetRoleByRoleCodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RoleService_ServiceDesc is the grpc.ServiceDesc for RoleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sysclient.RoleService",
	HandlerType: (*RoleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRoleList",
			Handler:    _RoleService_GetRoleList_Handler,
		},
		{
			MethodName: "CreateRole",
			Handler:    _RoleService_CreateRole_Handler,
		},
		{
			MethodName: "UpdateRole",
			Handler:    _RoleService_UpdateRole_Handler,
		},
		{
			MethodName: "ToggleRoleStatus",
			Handler:    _RoleService_ToggleRoleStatus_Handler,
		},
		{
			MethodName: "DeleteRole",
			Handler:    _RoleService_DeleteRole_Handler,
		},
		{
			MethodName: "BatchDeleteRoles",
			Handler:    _RoleService_BatchDeleteRoles_Handler,
		},
		{
			MethodName: "AddRolePerms",
			Handler:    _RoleService_AddRolePerms_Handler,
		},
		{
			MethodName: "UpdateRolePerms",
			Handler:    _RoleService_UpdateRolePerms_Handler,
		},
		{
			MethodName: "DeleteRolePerms",
			Handler:    _RoleService_DeleteRolePerms_Handler,
		},
		{
			MethodName: "GetRolePerms",
			Handler:    _RoleService_GetRolePerms_Handler,
		},
		{
			MethodName: "GetRoleListByRoleIDs",
			Handler:    _RoleService_GetRoleListByRoleIDs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/sys/sys.proto",
}

const (
	ScopeService_GetScopeList_FullMethodName     = "/sysclient.ScopeService/GetScopeList"
	ScopeService_GetScopeById_FullMethodName     = "/sysclient.ScopeService/GetScopeById"
	ScopeService_CreateScope_FullMethodName      = "/sysclient.ScopeService/CreateScope"
	ScopeService_UpdateScope_FullMethodName      = "/sysclient.ScopeService/UpdateScope"
	ScopeService_DeleteScope_FullMethodName      = "/sysclient.ScopeService/DeleteScope"
	ScopeService_AddScopeMenus_FullMethodName    = "/sysclient.ScopeService/AddScopeMenus"
	ScopeService_DeleteScopeMenus_FullMethodName = "/sysclient.ScopeService/DeleteScopeMenus"
	ScopeService_GetScopeMenus_FullMethodName    = "/sysclient.ScopeService/GetScopeMenus"
	ScopeService_GetMenuTree_FullMethodName      = "/sysclient.ScopeService/GetMenuTree"
	ScopeService_GetMenuById_FullMethodName      = "/sysclient.ScopeService/GetMenuById"
	ScopeService_CreateMenu_FullMethodName       = "/sysclient.ScopeService/CreateMenu"
	ScopeService_UpdateMenu_FullMethodName       = "/sysclient.ScopeService/UpdateMenu"
	ScopeService_DeleteMenu_FullMethodName       = "/sysclient.ScopeService/DeleteMenu"
)

// ScopeServiceClient is the client API for ScopeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ScopeServiceClient interface {
	// 安全范围管理
	GetScopeList(ctx context.Context, in *ScopeListRequest, opts ...grpc.CallOption) (*ScopeListResponse, error)
	GetScopeById(ctx context.Context, in *Int64Value, opts ...grpc.CallOption) (*Scope, error)
	CreateScope(ctx context.Context, in *CreateScopeRequest, opts ...grpc.CallOption) (*Scope, error)
	UpdateScope(ctx context.Context, in *UpdateScopeRequest, opts ...grpc.CallOption) (*Scope, error)
	DeleteScope(ctx context.Context, in *DeleteScopeRequest, opts ...grpc.CallOption) (*Empty, error)
	AddScopeMenus(ctx context.Context, in *AddScopeMenusRequest, opts ...grpc.CallOption) (*ScopeInfo, error)
	DeleteScopeMenus(ctx context.Context, in *DeleteScopeMenusRequest, opts ...grpc.CallOption) (*ScopeInfo, error)
	GetScopeMenus(ctx context.Context, in *Int64Value, opts ...grpc.CallOption) (*ScopeInfo, error)
	// 菜单管理
	GetMenuTree(ctx context.Context, in *MenuListRequest, opts ...grpc.CallOption) (*MenuTreeResponse, error)
	GetMenuById(ctx context.Context, in *Int64Value, opts ...grpc.CallOption) (*Menu, error)
	CreateMenu(ctx context.Context, in *CreateMenuRequest, opts ...grpc.CallOption) (*Menu, error)
	UpdateMenu(ctx context.Context, in *UpdateMenuRequest, opts ...grpc.CallOption) (*Menu, error)
	DeleteMenu(ctx context.Context, in *DeleteMenuRequest, opts ...grpc.CallOption) (*Empty, error)
}

type scopeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewScopeServiceClient(cc grpc.ClientConnInterface) ScopeServiceClient {
	return &scopeServiceClient{cc}
}

func (c *scopeServiceClient) GetScopeList(ctx context.Context, in *ScopeListRequest, opts ...grpc.CallOption) (*ScopeListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScopeListResponse)
	err := c.cc.Invoke(ctx, ScopeService_GetScopeList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scopeServiceClient) GetScopeById(ctx context.Context, in *Int64Value, opts ...grpc.CallOption) (*Scope, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Scope)
	err := c.cc.Invoke(ctx, ScopeService_GetScopeById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scopeServiceClient) CreateScope(ctx context.Context, in *CreateScopeRequest, opts ...grpc.CallOption) (*Scope, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Scope)
	err := c.cc.Invoke(ctx, ScopeService_CreateScope_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scopeServiceClient) UpdateScope(ctx context.Context, in *UpdateScopeRequest, opts ...grpc.CallOption) (*Scope, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Scope)
	err := c.cc.Invoke(ctx, ScopeService_UpdateScope_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scopeServiceClient) DeleteScope(ctx context.Context, in *DeleteScopeRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScopeService_DeleteScope_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scopeServiceClient) AddScopeMenus(ctx context.Context, in *AddScopeMenusRequest, opts ...grpc.CallOption) (*ScopeInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScopeInfo)
	err := c.cc.Invoke(ctx, ScopeService_AddScopeMenus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scopeServiceClient) DeleteScopeMenus(ctx context.Context, in *DeleteScopeMenusRequest, opts ...grpc.CallOption) (*ScopeInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScopeInfo)
	err := c.cc.Invoke(ctx, ScopeService_DeleteScopeMenus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scopeServiceClient) GetScopeMenus(ctx context.Context, in *Int64Value, opts ...grpc.CallOption) (*ScopeInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScopeInfo)
	err := c.cc.Invoke(ctx, ScopeService_GetScopeMenus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scopeServiceClient) GetMenuTree(ctx context.Context, in *MenuListRequest, opts ...grpc.CallOption) (*MenuTreeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuTreeResponse)
	err := c.cc.Invoke(ctx, ScopeService_GetMenuTree_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scopeServiceClient) GetMenuById(ctx context.Context, in *Int64Value, opts ...grpc.CallOption) (*Menu, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Menu)
	err := c.cc.Invoke(ctx, ScopeService_GetMenuById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scopeServiceClient) CreateMenu(ctx context.Context, in *CreateMenuRequest, opts ...grpc.CallOption) (*Menu, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Menu)
	err := c.cc.Invoke(ctx, ScopeService_CreateMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scopeServiceClient) UpdateMenu(ctx context.Context, in *UpdateMenuRequest, opts ...grpc.CallOption) (*Menu, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Menu)
	err := c.cc.Invoke(ctx, ScopeService_UpdateMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scopeServiceClient) DeleteMenu(ctx context.Context, in *DeleteMenuRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScopeService_DeleteMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScopeServiceServer is the server API for ScopeService service.
// All implementations must embed UnimplementedScopeServiceServer
// for forward compatibility.
type ScopeServiceServer interface {
	// 安全范围管理
	GetScopeList(context.Context, *ScopeListRequest) (*ScopeListResponse, error)
	GetScopeById(context.Context, *Int64Value) (*Scope, error)
	CreateScope(context.Context, *CreateScopeRequest) (*Scope, error)
	UpdateScope(context.Context, *UpdateScopeRequest) (*Scope, error)
	DeleteScope(context.Context, *DeleteScopeRequest) (*Empty, error)
	AddScopeMenus(context.Context, *AddScopeMenusRequest) (*ScopeInfo, error)
	DeleteScopeMenus(context.Context, *DeleteScopeMenusRequest) (*ScopeInfo, error)
	GetScopeMenus(context.Context, *Int64Value) (*ScopeInfo, error)
	// 菜单管理
	GetMenuTree(context.Context, *MenuListRequest) (*MenuTreeResponse, error)
	GetMenuById(context.Context, *Int64Value) (*Menu, error)
	CreateMenu(context.Context, *CreateMenuRequest) (*Menu, error)
	UpdateMenu(context.Context, *UpdateMenuRequest) (*Menu, error)
	DeleteMenu(context.Context, *DeleteMenuRequest) (*Empty, error)
	mustEmbedUnimplementedScopeServiceServer()
}

// UnimplementedScopeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedScopeServiceServer struct{}

func (UnimplementedScopeServiceServer) GetScopeList(context.Context, *ScopeListRequest) (*ScopeListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScopeList not implemented")
}
func (UnimplementedScopeServiceServer) GetScopeById(context.Context, *Int64Value) (*Scope, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScopeById not implemented")
}
func (UnimplementedScopeServiceServer) CreateScope(context.Context, *CreateScopeRequest) (*Scope, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateScope not implemented")
}
func (UnimplementedScopeServiceServer) UpdateScope(context.Context, *UpdateScopeRequest) (*Scope, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateScope not implemented")
}
func (UnimplementedScopeServiceServer) DeleteScope(context.Context, *DeleteScopeRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteScope not implemented")
}
func (UnimplementedScopeServiceServer) AddScopeMenus(context.Context, *AddScopeMenusRequest) (*ScopeInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddScopeMenus not implemented")
}
func (UnimplementedScopeServiceServer) DeleteScopeMenus(context.Context, *DeleteScopeMenusRequest) (*ScopeInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteScopeMenus not implemented")
}
func (UnimplementedScopeServiceServer) GetScopeMenus(context.Context, *Int64Value) (*ScopeInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScopeMenus not implemented")
}
func (UnimplementedScopeServiceServer) GetMenuTree(context.Context, *MenuListRequest) (*MenuTreeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuTree not implemented")
}
func (UnimplementedScopeServiceServer) GetMenuById(context.Context, *Int64Value) (*Menu, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuById not implemented")
}
func (UnimplementedScopeServiceServer) CreateMenu(context.Context, *CreateMenuRequest) (*Menu, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMenu not implemented")
}
func (UnimplementedScopeServiceServer) UpdateMenu(context.Context, *UpdateMenuRequest) (*Menu, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMenu not implemented")
}
func (UnimplementedScopeServiceServer) DeleteMenu(context.Context, *DeleteMenuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMenu not implemented")
}
func (UnimplementedScopeServiceServer) mustEmbedUnimplementedScopeServiceServer() {}
func (UnimplementedScopeServiceServer) testEmbeddedByValue()                      {}

// UnsafeScopeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ScopeServiceServer will
// result in compilation errors.
type UnsafeScopeServiceServer interface {
	mustEmbedUnimplementedScopeServiceServer()
}

func RegisterScopeServiceServer(s grpc.ServiceRegistrar, srv ScopeServiceServer) {
	// If the following call pancis, it indicates UnimplementedScopeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ScopeService_ServiceDesc, srv)
}

func _ScopeService_GetScopeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScopeListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScopeServiceServer).GetScopeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScopeService_GetScopeList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScopeServiceServer).GetScopeList(ctx, req.(*ScopeListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScopeService_GetScopeById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int64Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScopeServiceServer).GetScopeById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScopeService_GetScopeById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScopeServiceServer).GetScopeById(ctx, req.(*Int64Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScopeService_CreateScope_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateScopeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScopeServiceServer).CreateScope(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScopeService_CreateScope_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScopeServiceServer).CreateScope(ctx, req.(*CreateScopeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScopeService_UpdateScope_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScopeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScopeServiceServer).UpdateScope(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScopeService_UpdateScope_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScopeServiceServer).UpdateScope(ctx, req.(*UpdateScopeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScopeService_DeleteScope_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteScopeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScopeServiceServer).DeleteScope(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScopeService_DeleteScope_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScopeServiceServer).DeleteScope(ctx, req.(*DeleteScopeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScopeService_AddScopeMenus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddScopeMenusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScopeServiceServer).AddScopeMenus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScopeService_AddScopeMenus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScopeServiceServer).AddScopeMenus(ctx, req.(*AddScopeMenusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScopeService_DeleteScopeMenus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteScopeMenusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScopeServiceServer).DeleteScopeMenus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScopeService_DeleteScopeMenus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScopeServiceServer).DeleteScopeMenus(ctx, req.(*DeleteScopeMenusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScopeService_GetScopeMenus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int64Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScopeServiceServer).GetScopeMenus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScopeService_GetScopeMenus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScopeServiceServer).GetScopeMenus(ctx, req.(*Int64Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScopeService_GetMenuTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScopeServiceServer).GetMenuTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScopeService_GetMenuTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScopeServiceServer).GetMenuTree(ctx, req.(*MenuListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScopeService_GetMenuById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int64Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScopeServiceServer).GetMenuById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScopeService_GetMenuById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScopeServiceServer).GetMenuById(ctx, req.(*Int64Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScopeService_CreateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScopeServiceServer).CreateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScopeService_CreateMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScopeServiceServer).CreateMenu(ctx, req.(*CreateMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScopeService_UpdateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScopeServiceServer).UpdateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScopeService_UpdateMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScopeServiceServer).UpdateMenu(ctx, req.(*UpdateMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScopeService_DeleteMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScopeServiceServer).DeleteMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScopeService_DeleteMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScopeServiceServer).DeleteMenu(ctx, req.(*DeleteMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ScopeService_ServiceDesc is the grpc.ServiceDesc for ScopeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ScopeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sysclient.ScopeService",
	HandlerType: (*ScopeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetScopeList",
			Handler:    _ScopeService_GetScopeList_Handler,
		},
		{
			MethodName: "GetScopeById",
			Handler:    _ScopeService_GetScopeById_Handler,
		},
		{
			MethodName: "CreateScope",
			Handler:    _ScopeService_CreateScope_Handler,
		},
		{
			MethodName: "UpdateScope",
			Handler:    _ScopeService_UpdateScope_Handler,
		},
		{
			MethodName: "DeleteScope",
			Handler:    _ScopeService_DeleteScope_Handler,
		},
		{
			MethodName: "AddScopeMenus",
			Handler:    _ScopeService_AddScopeMenus_Handler,
		},
		{
			MethodName: "DeleteScopeMenus",
			Handler:    _ScopeService_DeleteScopeMenus_Handler,
		},
		{
			MethodName: "GetScopeMenus",
			Handler:    _ScopeService_GetScopeMenus_Handler,
		},
		{
			MethodName: "GetMenuTree",
			Handler:    _ScopeService_GetMenuTree_Handler,
		},
		{
			MethodName: "GetMenuById",
			Handler:    _ScopeService_GetMenuById_Handler,
		},
		{
			MethodName: "CreateMenu",
			Handler:    _ScopeService_CreateMenu_Handler,
		},
		{
			MethodName: "UpdateMenu",
			Handler:    _ScopeService_UpdateMenu_Handler,
		},
		{
			MethodName: "DeleteMenu",
			Handler:    _ScopeService_DeleteMenu_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/sys/sys.proto",
}

const (
	UserService_GetUserList_FullMethodName        = "/sysclient.UserService/GetUserList"
	UserService_GetUserById_FullMethodName        = "/sysclient.UserService/GetUserById"
	UserService_CreateUser_FullMethodName         = "/sysclient.UserService/CreateUser"
	UserService_UpdateUser_FullMethodName         = "/sysclient.UserService/UpdateUser"
	UserService_DeleteUser_FullMethodName         = "/sysclient.UserService/DeleteUser"
	UserService_UpdateUserPassword_FullMethodName = "/sysclient.UserService/UpdateUserPassword"
	UserService_AssignUserRole_FullMethodName     = "/sysclient.UserService/AssignUserRole"
	UserService_ToggleUserStatus_FullMethodName   = "/sysclient.UserService/ToggleUserStatus"
	UserService_GetUserInfo_FullMethodName        = "/sysclient.UserService/GetUserInfo"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	// 用户管理
	GetUserList(ctx context.Context, in *UserListRequest, opts ...grpc.CallOption) (*UserListResponse, error)
	GetUserById(ctx context.Context, in *Int64Value, opts ...grpc.CallOption) (*UserInfo, error)
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*UserInfo, error)
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error)
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*Empty, error)
	UpdateUserPassword(ctx context.Context, in *UpdateUserPasswordRequest, opts ...grpc.CallOption) (*Empty, error)
	AssignUserRole(ctx context.Context, in *AssignUserRoleRequest, opts ...grpc.CallOption) (*Empty, error)
	ToggleUserStatus(ctx context.Context, in *ToggleUserStatusRequest, opts ...grpc.CallOption) (*User, error)
	// 获取当前用户信息
	GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*UserInfo, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) GetUserList(ctx context.Context, in *UserListRequest, opts ...grpc.CallOption) (*UserListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserListResponse)
	err := c.cc.Invoke(ctx, UserService_GetUserList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserById(ctx context.Context, in *Int64Value, opts ...grpc.CallOption) (*UserInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, UserService_GetUserById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*UserInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUserPassword(ctx context.Context, in *UpdateUserPasswordRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserService_UpdateUserPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) AssignUserRole(ctx context.Context, in *AssignUserRoleRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, UserService_AssignUserRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ToggleUserStatus(ctx context.Context, in *ToggleUserStatusRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_ToggleUserStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*UserInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, UserService_GetUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	// 用户管理
	GetUserList(context.Context, *UserListRequest) (*UserListResponse, error)
	GetUserById(context.Context, *Int64Value) (*UserInfo, error)
	CreateUser(context.Context, *CreateUserRequest) (*UserInfo, error)
	UpdateUser(context.Context, *UpdateUserRequest) (*User, error)
	DeleteUser(context.Context, *DeleteUserRequest) (*Empty, error)
	UpdateUserPassword(context.Context, *UpdateUserPasswordRequest) (*Empty, error)
	AssignUserRole(context.Context, *AssignUserRoleRequest) (*Empty, error)
	ToggleUserStatus(context.Context, *ToggleUserStatusRequest) (*User, error)
	// 获取当前用户信息
	GetUserInfo(context.Context, *GetUserInfoRequest) (*UserInfo, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) GetUserList(context.Context, *UserListRequest) (*UserListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserList not implemented")
}
func (UnimplementedUserServiceServer) GetUserById(context.Context, *Int64Value) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserById not implemented")
}
func (UnimplementedUserServiceServer) CreateUser(context.Context, *CreateUserRequest) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *DeleteUserRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServiceServer) UpdateUserPassword(context.Context, *UpdateUserPasswordRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserPassword not implemented")
}
func (UnimplementedUserServiceServer) AssignUserRole(context.Context, *AssignUserRoleRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignUserRole not implemented")
}
func (UnimplementedUserServiceServer) ToggleUserStatus(context.Context, *ToggleUserStatusRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToggleUserStatus not implemented")
}
func (UnimplementedUserServiceServer) GetUserInfo(context.Context, *GetUserInfoRequest) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_GetUserList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserList(ctx, req.(*UserListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int64Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserById(ctx, req.(*Int64Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUserPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUserPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUserPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUserPassword(ctx, req.(*UpdateUserPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_AssignUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignUserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).AssignUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_AssignUserRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).AssignUserRole(ctx, req.(*AssignUserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ToggleUserStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleUserStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ToggleUserStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ToggleUserStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ToggleUserStatus(ctx, req.(*ToggleUserStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserInfo(ctx, req.(*GetUserInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sysclient.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserList",
			Handler:    _UserService_GetUserList_Handler,
		},
		{
			MethodName: "GetUserById",
			Handler:    _UserService_GetUserById_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
		{
			MethodName: "UpdateUserPassword",
			Handler:    _UserService_UpdateUserPassword_Handler,
		},
		{
			MethodName: "AssignUserRole",
			Handler:    _UserService_AssignUserRole_Handler,
		},
		{
			MethodName: "ToggleUserStatus",
			Handler:    _UserService_ToggleUserStatus_Handler,
		},
		{
			MethodName: "GetUserInfo",
			Handler:    _UserService_GetUserInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/sys/sys.proto",
}
